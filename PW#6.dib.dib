#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!markdown

// здесь писать код

#!csharp

using System;
using System.Diagnostics;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;

List<double> timeBlockingCollection = new();
   static void TimeBlockingCollection()
    {
        BlockingCollection<int> blockingCollection = new BlockingCollection<int>();
        Stopwatch stopwatch = new Stopwatch();
        ManualResetEventSlim startWaitThread = new ManualResetEventSlim(false);
        ManualResetEventSlim startReadyThread = new ManualResetEventSlim(false);
        int num = 0;
        //производитель
        Task thread1 = Task.Run(() =>{
            startReadyThread.Set();
            startWaitThread.Wait();
            stopwatch.Start();

            for (int i = 0; i<1000000; i++) {
                blockingCollection.Add(i);
                num+=1;} blockingCollection.CompleteAdding();});
        //потребитель
        Task thread2 = Task.Run(() => {
            startReadyThread.Set();
            startWaitThread.Wait();

            //потребител
            foreach (var item in blockingCollection.GetConsumingEnumerable()) { blockingCollection.Take(); num-=1;}

            stopwatch.Stop();});

        startReadyThread.Wait();
        startWaitThread.Set(); 
        
        Task.WaitAll(thread1, thread2);
        Console.WriteLine($"BlockingCollection: Время записи и чтения миллиона объектов: {stopwatch.ElapsedMilliseconds} мс {num} 44");
    }

#!csharp

static void TimeConcurrentQueue()
    {
        ConcurrentQueue<int> concurrentQueue = new ConcurrentQueue<int>();
        Stopwatch stopwatch = new Stopwatch();
        ManualResetEventSlim startWaitThread = new ManualResetEventSlim(false);
        ManualResetEventSlim startReadyThread = new ManualResetEventSlim(false);

        //производитель
        Task thread1 = Task.Run(() =>{
            startReadyThread.Set();
            startWaitThread.Wait();
            stopwatch.Start();
            
            for (int i=0; i< 1000000; i++) concurrentQueue.Enqueue(i);});
        //потребитель
        Task thread2 = Task.Run(() =>{
            startReadyThread.Set();
            startWaitThread.Wait();
            int result;
            
            //потребитель
            for (int i = 0; i < 1000000; i++) concurrentQueue.TryDequeue(out result);
            stopwatch.Stop();});

        startReadyThread.Wait();
        startWaitThread.Set(); 

        Task.WaitAll(thread1, thread2);
        Console.WriteLine($"ConcurrentQueue: Время записи и чтения миллиона объектов: {stopwatch.ElapsedMilliseconds} мс");
    }

#!csharp

static void TimeQueue()
    {
        Queue<int> queue = new Queue<int>();
        Stopwatch stopwatch = new Stopwatch();

        //производитель
        stopwatch.Start();
        for (int i = 0; i < 1000000; i++) queue.Enqueue(1);

        //потребитель
        for (int i = 0; i < 1000000; i++)queue.Dequeue();
        stopwatch.Stop();

        Console.WriteLine($"Queue: Время записи и чтения миллиона объектов: {stopwatch.ElapsedMilliseconds} мс");
    }    

#!csharp

TimeBlockingCollection();
TimeConcurrentQueue();
TimeQueue();

#!markdown

## Вывод
